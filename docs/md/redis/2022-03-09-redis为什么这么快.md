
# redis为什么这么快 🛫

> 你好，我是溯，一名普通的开发。

一个着迷于技术又喜欢不断折腾的技术活跃者，从16年毕业进入互联网，开发过交易、营销类项目，实现过运营、活动类项目，设计过中间件，组织过系统重构，对架构的设计和落地有丰富的经验。

## 零、知识关键点

- 数据结构
- 底层数据结构
- redis是如何找数据的
- redis是如何rehash的

## 一、介绍
数据库这么多，为啥 Redis 能有这么突出的表现呢？

一提到高并发必定会提到缓存，一提到缓存必定会提到redis，那么今天讲一下redis为什么这么快，它快在哪里？

数据库这么多，为啥 Redis 能有这么突出的表现呢？

- 内存数据库
- 数据结构
- IO多路复用
- 文件事件分派器

今天首先聊数据结构

## 二、数据结构

谈起redis的数据结构就有了网上铺天盖地的 String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）
但是，这些只是 Redis 键值对中值的数据类型，也就是数据的保存形式。而这里，我们说的数据结构，是要去看看它们的底层实现。
简单来说，底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：

![Redis数据类型和底层数据结构对应关系](https://raw.githubusercontent.com/ekkoxusu/ekkoxusu.github.io/master/docs/assets/img/redis/Redis数据类型和底层数据结构对应关系.jpg)

产生以下几个问题：

- 这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？
- 为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？
- 什么是简单动态字符串？

## 三、键和值用什么结构组织？

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。

一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。

看到这里，你可能会问了：“如果值是集合类型的话，作为数组元素的哈希桶怎么来保存呢？”其实，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。

在下图中，可以看到，哈希桶中的 entry 元素中保存了*key和*value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。

![全局哈希表](https://raw.githubusercontent.com/ekkoxusu/ekkoxusu.github.io/master/docs/assets/img/redis/全局哈希表.jpg)

因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。

但是这里有一个问题，哈希表是会产生冲突和rehash的，这一部分操作会产生阻塞，对于redis这种追求毫秒级返回的缓存数据库是要尽量避免这种情况的。

Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指**同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。[类似于HashMap]

但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。

所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？

其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；

2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；

3. 释放哈希表 1 的空间。

这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。

为了避免这个问题，Redis 采用了**渐进式 rehash**。



## 渐进式rehash

简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。具体流程如下图：

<img src="https://raw.githubusercontent.com/ekkoxusu/ekkoxusu.github.io/master/docs/assets/img/redis/redis.jpg" alt="redis" style="zoom: 67%;" />

由此产生了以下两个问题

1. 如果在一次请求之后没有后续请求了，那么全局哈希表rehash会停止在这一步吗？

2. 如果此时进入了增删改请求会如何？

回答：

1. 渐进式rehash执行时，除了根据键值对的操作来进行数据迁移，Redis本身还会有一个定时任务在执行rehash，如果没有键值对操作时，这个定时任务会周期性地（例如每100ms一次）搬移一些数据到新的哈希表中，这样可以缩短整个rehash的过程。

2. 因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。
   另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。

   即如果在此时遇到请求会先判断是否正在rehash，如果正在rehash则会先查全局哈希表1再查全局哈希表2，如果是新增则只在哈希表2去新增保证哈希表1只减不增
